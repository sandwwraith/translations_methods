@file:JvmName("App")

package top.sandwwraith.mt.lab3v7

import org.antlr.v4.runtime.CharStreams
import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.tree.TerminalNode

/**
 * @author Leonid Startsev
 *		  sandwwraith@gmail.com
 * 		  ITMO University, 2017
 **/

class RatNumTranspiler : RatNumsBaseVisitor<String>() {

    private fun StringBuilder.al(a: String) {
        for (i in 0 until (4 * indent)) append(" ")
        append(a)
        append(System.lineSeparator())
    }

    private var indent = 0

    private val contextStack: MutableList<Context> = ArrayList()

    private fun newScope(block: () -> Unit) {
        indent++
        val c = if (contextStack.isNotEmpty()) contextStack.last().counter else 0
        contextStack.add(Context(c))
        block()
        if (contextStack.last().allocated.isNotEmpty()) println("WARNING: not all variables have been deallocated")
        contextStack.removeAt(contextStack.size - 1)
        indent--
    }

    private val curContext
        get() = contextStack.last()

    private val SUBST_TYPE = "mpq_t"
    private val RETURN_PARAM = "_out_param"
    private val HEADER = """#include <gmp.h>
#include <stdio.h>

// Auto-Generated by RatNums 0.1
"""

    object functions {
        operator fun get(funcText: String) = when (funcText) {
            "+" -> "mpq_add"
            "*" -> "mpq_mul"
            "-" -> "mpq_sub"
            "/" -> "mpq_div"
            else -> throw IllegalArgumentException("No such operation")

        }
    }

    object builtins {
        operator fun contains(f: String) = f in setOf("<<", ">>")

        operator fun get(f: String, arg: String, indent: Int = 0) = when (f) {
            "<<" -> "mpq_out_str(stdout, 10, $arg);"
            ">>" -> "mpq_inp_str($arg, stdin, 10);\n${" ".repeat(4 * indent)}mpq_canonicalize($arg);"
            else -> throw IllegalArgumentException("No such built-in function")
        }
    }

    override fun aggregateResult(aggregate: String?, nextResult: String?): String {
        return (aggregate ?: "") + (nextResult ?: "")
    }

    private fun buildFuncSignature(funcName: String, args: List<String>): String {
        val argl = (args.asSequence() + RETURN_PARAM).map { "$SUBST_TYPE $it" }
        return "$SUBST_TYPE $funcName(${argl.joinToString()})"
    }

    override fun visitProgram(ctx: RatNumsParser.ProgramContext) = buildString {
        al(HEADER)
        ctx.func().forEach {
            append(visitFunc(it))
            al("")
        }
        ctx.main()?.let {
            append(visitMain(it))
        }
    }

    override fun visitFunc(ctx: RatNumsParser.FuncContext) = buildString {
        val name = ctx.ID(0).toString()
        val args = ctx.ID().subList(1, ctx.ID().size).map { it.toString() }
        al("${buildFuncSignature(name, args)} {")
        newScope {
            ctx.lines()?.let { append(visitLines(it)) }
            append(visitRet(ctx.ret()))
            append(deallocateVars(curContext))
        }
        al("}")
    }

    override fun visitMain(ctx: RatNumsParser.MainContext) = buildString {
        al("int main() {")
        newScope {
            append(visitLines(ctx.lines()))
            append(deallocateVars(curContext))
            al("return 0;")
        }
        al("}")
    }

    private fun deallocateVars(context: Context) = buildString {
        al("mpq_clears(${context.allocated.joinToString()}, 0);")
        context.allocated.clear()
    }

    override fun visitRet(ctx: RatNumsParser.RetContext) = buildString {
        val txt = visitArithm(ctx.arithm())
        append(txt)
        val resultVar = curContext.popStack()
        al("mpq_set($RETURN_PARAM, $resultVar);")
    }

    override fun visitExt_call(ctx: RatNumsParser.Ext_callContext) = buildString {
        al(ctx.text + ";")
    }

    override fun visitCall(ctx: RatNumsParser.CallContext) = buildString {
        val funName = ctx.ID(0).toString()
        val args = ctx.ID().subList(1, ctx.ID().size - 1).map { it.toString() }
        val outParam = ctx.ID().last().toString()
        checkVar(outParam)
        al("$funName(${if (args.isNotEmpty()) args.joinToString(postfix = ", ") else ""}$outParam);")
    }

    private fun StringBuilder.checkVar(v: String) {
        if (v !in curContext.allocated) append(introduceVariable(v))
    }

    override fun visitIo(ctx: RatNumsParser.IoContext) = buildString {
        val dir = ctx.getChild(0).text
        ctx.ID().asSequence()
                .map { it.toString() }
                .onEach { checkVar(it) }
                .forEach { al(builtins[dir, it, indent]) }
    }

    override fun visitDef(ctx: RatNumsParser.DefContext): String {
        val varname = ctx.ID().toString()
        return introduceVariable(varname)
    }

    override fun visitAssign(ctx: RatNumsParser.AssignContext) = buildString {
        val varname = ctx.ID().toString()
        checkVar(varname)
        val txt = visitArithm(ctx.arithm())
        // expression
        append(txt)
        val resultVar = curContext.popStack()
        al("mpq_set($varname, $resultVar);")
        curContext.releaseTmpVar(resultVar)
    }

    override fun visitArithm(ctx: RatNumsParser.ArithmContext): String {
        if (ctx.childCount == 1) return visitFst(ctx.fst())
        return performBinaryOp(visitArithm(ctx.arithm()), visitFst(ctx.fst()), ctx.getChild(1).text)
    }

    override fun visitFst(ctx: RatNumsParser.FstContext): String {
        if (ctx.childCount == 1) return visitScnd(ctx.scnd())
        return performBinaryOp(visitFst(ctx.fst()), visitScnd(ctx.scnd()), ctx.getChild(1).text)
    }

    private fun performBinaryOp(txt1: String, txt2: String, op: String): String {
        return buildString {
            append(txt1)
            append(txt2)
            val (resvar, new) = curContext.getTmpVar()
            if (new) append(introduceVariable(resvar))
            val funtxt = functions[op]
            val op2 = curContext.popStack()
            val op1 = curContext.popStack()
            al("$funtxt($resvar, $op1, $op2);")
            with(curContext) {
                pushStack(resvar)
                releaseTmpVar(op1)
                releaseTmpVar(op2)
            }
        }
    }

    override fun visitScnd(ctx: RatNumsParser.ScndContext): String {
        if (ctx.childCount == 1) return visitPrimary(ctx.primary())
        return buildString {
            append(visitScnd(ctx.scnd()))
            val (resvar, new) = curContext.getTmpVar()
            if (new) append(introduceVariable(resvar))
            val op = curContext.popStack()
            al("mpq_neg($resvar, $op);")
            curContext.pushStack(resvar)
            curContext.releaseTmpVar(op)
        }
    }

    override fun visitPrimary(ctx: RatNumsParser.PrimaryContext): String {
        if (ctx.childCount > 1) {
            return visitArithm(ctx.arithm())
        }
        val node = ctx.getChild(0) as TerminalNode
        if (node.symbol.type == RatNumsParser.ID) {
            curContext.pushStack(node.text)
            return ""
        } else {
            return buildString {
                val (varname, new) = curContext.getTmpVar()
                if (new)
                    append(introduceVariable(varname))
                al("mpq_set_ui($varname, ${node.text}, 1);")
                curContext.pushStack(varname)
            }
        }
    }

    private fun introduceVariable(varname: String) = buildString {
        curContext.allocated.add(varname)
        al("$SUBST_TYPE $varname;")
        al("mpq_init($varname);")
    }
}

class Context(initCounter: Int = 0) {
    val allocated: MutableSet<String> = HashSet()

    private val tmpVars: MutableSet<String> = HashSet()
    private val freeTmps: MutableSet<String> = LinkedHashSet()
    var counter = initCounter
        private set

    private val exprStack: MutableList<String> = ArrayList()

    fun createTmpVar(): String {
        val varname = "_tmp_var${counter++}"
        allocated.add(varname)
        tmpVars.add(varname)
        return varname
    }

    fun getTmpVar(): Pair<String, Boolean> {
        return if (freeTmps.isNotEmpty()) {
            val r = freeTmps.first()
            freeTmps.remove(r)
            r to false
        } else createTmpVar() to true
    }

    fun releaseTmpVar(v: String) = if (v in tmpVars) freeTmps.add(v) else false

    fun pushStack(v: String) = exprStack.add(v)

    fun popStack(): String {
        val r = exprStack.last()
        exprStack.removeAt(exprStack.size - 1)
        return r
    }

    fun stackIsEmpty() = exprStack.isEmpty()
}


fun main(args: Array<String>) {
    val lexer = RatNumsLexer(CharStreams.fromString("fun g() {ret 10} main {>> x i g() -> i y = (x+i) << y}"))
    val parser = RatNumsParser(CommonTokenStream(lexer))
    val trans = RatNumTranspiler()
    println(trans.visit(parser.program()))
}